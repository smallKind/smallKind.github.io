---
layout: post
title: 全文索引
date: 2016-10-30 22:00:01 +8000
category: MySQL
tags: 索引
---

* content
{:toc}

### 前言

调用第三方登陆，都会返回一个open_id，该open_id对于该用户是唯一的，根据该open_id可以调用第三方的该用户基本信息。在项目设计前期，用户表中有OPEN_ID字段用来存放第三方的open_id，后需求新增绑定功能，手机用户，微信，QQ可以互相绑定。原先的数据库表结构，就无法合理的去满足这个需求。在仔细的思考之后，就把第三方登陆的open_id全存放在OPEN_ID这列中，以“,”分隔。每次查询该open_id是否已经注册或者绑定，用SQL中FIND_IN_SET()函数查找OPEN_ID这列中是否含有该open_id。这也就导致后面出现的一系列问题。

在项目由1.0版本（可单机运行）升级到2.0版本（全与服务器交互），用户量瞬间暴涨，每次查询都全表扫描，数据库每秒查询磁盘中数据行达到几百万行，磁盘I/O占据大量的cpu、内存等系统资源，导致数据库查询响应时间变长，致使整个服务响应过慢。

在发现响应时间变慢之后，找到原因。迅速升级服务器配置，建立索引，通过索引快速查询到记录，从而避免查询每次全表扫描。因为OPEN_ID这列是唯一的，所以当时也为这列建立的唯一索引。完成这些之后，瞬间服务恢复过来，响应时间迅速。

事后恶补了关于数据库索引方面的知识，发现InnoDB不支持函数索引，也就是在SQL语句中使用函数，MySQL服务器是不会使用索引。也就是第三方登陆时，根据open_id查询用户信息还是全表扫描。也发现应用在第三方登陆确实响应时间有点长，怎么优化了，这也就引出了全文索引。

### 全文索引的概念

>一种通过建立倒排索引，快速匹配文档的方式

### 全文索引的模式

MySQL5.6版本才开始支持InnoDB引擎的全文索引，语法层面上大多数兼容之前MyISAM的全文索引模式。全文索引可以支持各种字符内容的索引（包括CHAR,VARCHAR和TEXT类型）。MySQL支持三种模式的全文检索模式：

1.自然语言模式（IN NATURAL LANGUAGE MODE），将计算每一个文档对象和查询的相关度。这里，相关度是基于匹配的关键词个数，以及关键词在文档出现的次数。在整个索引中出现次数越少的词语，匹配时的相关度就越高。如果一个词语在超过50%的记录中都出现了，那么自然语言模式也就不会搜索这类词语。函数MATCH()返回的是关键词匹配的相关度，是一个浮点数。这也意味着无法使用全文索引来查询某个关键字是否在某一列中存在。

2.布尔模式（IN BOOLEAN MODE），用户可以在查询中自定义某个被搜索的词语的相关性，例如“+”表示必须包含，“-”表示不包含，“*”表示通配符（这种情况， 即使传递的字符串较小或出现在停词中，也不会被过滤掉），其他还有很多特殊的布尔操作符，可以通过如下参数控制：

    mysql> show variables like '%ft_boolean_syntax%';
    +-------------------+----------------+
    | Variable_name     | Value          |
    +-------------------+----------------+
    | ft_boolean_syntax | + -><()~*:""&| |
    +-------------------+----------------+
    1 row in set (0.00 sec)
    + : 用在词的前面，表示一定要包含该词，并且必须在开始位置。
    - : 不包含该词，所以不能只用「-yoursql」这样是查不到任何row的，必须搭配其他语法使用。
    空(也就是默认情况)，表示可选的，包含该词的顺序较高。
    > :提高该字的相关性，查询的结果会排在比较靠前的位置。
    < :降低相关性，查询的结果会排在比较靠后的位置。
    ( )：可以通过括号来使用字条件。
    ~ :将其相关性由正转负，表示拥有该字会降低相关性，但不像「-」将之排除，只是排在较后面。
    * :通配符，这个只能接在字符串后面。
    " " :整体匹配，用双引号将一段句子包起来表示要完全相符，不可拆字。

3.查询扩展模式（WITH QUERY EXPANSION）,这种模式是自然语言模式下的一个变种，会执行两次检索，第一次使用给定的短语进行检索，第二次是结合第一次相关性比较高的行进行检索。

### 全文索引的缺点

但同样相比其他的索引，当INSERT,UPDATE,DELETE操作进行时，全文索引的操作代价很大：

1. 修改一段文本中的100个单词，需要100次索引操作，而不是一次
2. 一般来说列长度并不会太影响其他的索引类型，但是如果是全文索引，三个单词和1000个单词的文本，性能可能会差几个数量级
3. 全文索引会有更多的碎片，可能需要做更多的OPTIMIZE TABLE操作

全文索引还会影响查询优化器的工作。索引选择、WHERE子句、ORDER BY 都有可能不是按照你所预想的方式来工作。

1. 如果查询中使用了MATCH AGAINST子句，而对应列上又有可用的全文索引，那么MySQL就一定会使用这个全文索引。即使有其他索引可以用使用，MySQL也不会比较到底哪个索引的性能更好。
2. 全文索引只能用作全文搜索匹配。任何其他操作，如WHERE条件比较，都必须在MySQL完成全文搜索返回记录才能进行。这和其他普通索引不同，例如，在处理WHERE条件时，MySQL可以使用普通索引一次判断多个比较表达式。
3. 全文索引不存储列的实际值，也就不能进行覆盖索引扫描。
4. 除了相关性排序，全文索引不能用作其他的排序。如果需要使用其他排序，都需要使用文件排序。

### 实际应用场景的解决方案

在实际场景中，需要查询某个关键字是否在某一列中存在。也就是open_id在OPEN_ID这列中的某一列是否包含。自然语言模式和查询扩展模式都是根据相关度来进行匹配，也就是说虽然OPEN_ID在实际应用中是唯一的，但open_id字段前几个字符串可能相同，根据相关度也会查询出很多结果，所以无法用这两种模式来进行精确匹配。在布尔模式中，因为“-”是特殊操作符，代表不包含该词。而在微信open_id中字符串包含“-”，索引也不行。但‘“”’整体匹配，不可拆字，可以让返回结果可以精确匹配到指定的短语。结合实际用于场景，看到了曙光。

    select * from user where MATCH(OPEN_ID) AGAINST('"oouJmwzI-KK40gGRxlCWllQ_Utc8"' IN BOOLEAN MODE);

刚好可以精确匹配到唯一结果。用explain分析SQL语句，FIND_IN_SET()函数响应时间在0.x秒，用子查询响应时间在0.0x秒，而用全文索引响应时间在0.00x秒。相比之下已经是几个shu数量级的提升了。

但是这种短语搜索的速度会比较慢。只使用全文索引是无法判断是否精确匹配短语的，通常还需要查询原文确定记录中是否包含完整的短语。由于需要进行回表过滤，所以速度会很慢。

参考：

1. 《高性能的MySQL》(第三版)
