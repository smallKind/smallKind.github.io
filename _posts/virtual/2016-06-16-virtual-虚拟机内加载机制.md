---
layout: post
title: 虚拟机类加载机制
date: 2016-06-16 22:00:01 +8000
category: JVM
tags: 加载机制
---

* content
{:toc}

### 类加载的时机

类从被加载到虚拟机内存中，到卸载出内存为止，它的整个生命周期包括了：加载，验证，准备，解析，初始化，使用，卸载七个阶段，其中验证，准备，解析三个部分统称为连接。

![](/img/virtual/classLifecycle.png)

加载，验证，准备，初始化，卸载这五个阶段的顺序是确定，类的加载过程是按这个顺序按部就班的**开始**，而解析却不一定，它在某些情况下可以在初始化之后开始，这是为了支持Java的运行时绑定。

### 类加载的过程

类加载的全过程，也就是加载，验证，准备，解析和初始化这五个阶段的过程。

#### 加载

在加载阶段，虚拟机需要完成以下三件事：

1. [通过一个类的全限定名来获取此类的二进制字节流]()
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口

相对于类加载过程的其他阶段，加载阶段（准确的说，是加载阶段中获取类的二进制字节流的动作）是开发期可控性最强的阶段，因为加载阶段既可以使用系统提供的类加载器完成，也可以由用户自己定义的类加载器去完成。

#### 验证

验证是连接阶段的第一步,这一阶段的目的就是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

1. 文件格式验证：第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理
2. 元数据验证：第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求
3. 字节码验证：第三阶段是进行数据流和控制流分析
4. 符号引用验证：最后一阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段-解析阶段发生

#### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。这里的进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量，实例变量将在对象实例化随着对象一起分配到Java堆中。这里说的初始值，“通常情况“下是数据类型的零值。

![](/img/virtual/zero.png)

#### 解析

解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。

符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可

直接引用：直接引用可以是直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄

虚拟机规范中并没有规定解析阶段的具体时间，只要求在执行anewarray，checkcast，getfield，getstatic，instanceof，invokeinterface，invokespecial，invokestatic，invokevirtual，multianewarray，new，putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对于它们的所使用的符号引用进行解析，解析之前又需要进行符号引用的验证。

解析动作主要是对类或接口，字段，类方法，接口方法四类符号引用进行。

#### 初始化

类初始化是类加载过程的最后一个阶段。虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：

* 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的 Java 代码场景是：使用 new 关键字实例化对象时、读取或设置一个类的静态字段（static）时（被 static 修饰又被 final 修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。
* 使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。
* 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
* 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。

到初始化阶段，才开始真正执行类中定义的Java程序代码（字节码）。在准备阶段，变量已经赋值过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，换一个角度说，初始化阶段就是执行类构造器&lt;clinit>()方法的过程。

* &lt;clinit>()是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并成产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的
* &lt;clinit>()方法与类的构造函数（或者说实例构造器&lt;init>()方法）不同，它不需要显示地调用父类构造器，虚拟机会保证子类的&lt;clinit>()方法执行之前，父类的&lt;clinit>()方法已经执行完毕
* 由于父类的&lt;clinit>()方法先执行，也意味着父类中定义的静态语句块要优先于子类的变量赋值操作
* &lt;clinit>()方法对于类或接口来说不是必须的，如果一个类没有静态语句块，也没有对变量的赋值操作，那么编译器也不会生成&lt;clinit>()方法
* 虚拟机保证一个类的&lt;clinit>()方法在多线程下环境中会被正确的加锁同步，如果多个线程去初始化一个类，那么只有一个线程去执行这个类的&lt;clinit>()方法，其他线程需要阻塞等待，知道活动线程执行完&lt;clinit>()方法

参考：

1.《深入理解Java虚拟机》




