---
layout: post
title: Java内存区域和内存溢出异常
date: 2016-05-29 22:00:01 +8000
category: JVM
tags: 内存区域
---

* content
{:toc}

### Java内存区域和内存溢出异常

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。

![](/img/virtual/1.png)

#### 程序计数器

>是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成。为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，所以程序计数器它是线程私有的。

此内存区域是Java虚拟机规范中唯一一个没有规定任何OutOfMemoryError情况的区域。

#### Java虚拟机栈

>与线程的生命周期相同，描述的是Java方法执行的内存模型

每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每个方法被调用直至执行完成的过程，就对应着一个栈帧从虚拟机栈从入栈到出站的过程。

Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;如果虚拟机可以动态扩展，当扩展无法申请到足够的内存时会抛出OutOfMemoryError异常。

#### 本地方法栈

>是为虚拟机所用到的Native方法服务

本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。和虚拟机栈很大相似。

#### Java堆

>是被所有线程共享的一块内存区域，在虚拟机启动时创建，唯一目的就是存放对象实例

几乎所有的对象实例都在这里分配内存。Java堆是垃圾回收器管理的主要区域。如果在堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError异常。

#### 方法区

>是被所有线程共享的一块内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据

运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法和接口描述等信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用。

当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

### 对象访问

在Java语言中对象是如何访问的？即使是最简单的对象访问，也会涉及到Java栈，Java堆，方法区这三个最中烟的内存区域。

    Object o = new Object();

“Object o“这部分语义会反映到Java栈的本地变量表中，作为一个引用类型数据出现。而“new Object()”会反映到Java堆中，形成一块存储Object类型所有实例数据值的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存的长度是不固定的。另外，Java堆中还必须包含能查到此对象类型数据（如对象类型，父类，实现的接口，方法等）的地址信息。，这些类型数据则存储在方法区。

由于引用类型在Java虚拟机规范只规定一个指向对象的引用，但是没有定义这个引用通过哪种方式去定位。

主流的有两种：

1. 句柄
2. 直接指针

#### 句柄访问方式

Java堆会划分一块内存作为句柄池。引用中存的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。

![](/img/virtual/2.png)

使用句柄访问方式最大的好处就是引用存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）只会改变句柄的实例数据指针，而引用本身不需要改变。

#### 直接指针访问方式

Java堆对象的布局中就必须考虑如何访问类型数据的相关信息，引用中直接存储的就是对象地址。

![](/img/virtual/3.png)

使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。由于对象访问非常频繁，因此这类开销积少成多也是一项非常可观的成本。

参考：

1. 《深入理解Java虚拟机》

