---
layout: post
title: 类加载器
date: 2016-06-23 22:00:01 +8000
category: JVM
tags: jvm
---

* content
{:toc}

类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”，这个是如何实现的？

虚拟机设计团队把这个动作放到了Java虚拟机外部去实现，以便让应用程序自己去决定如何去获取所需要的类。实现这个动作的代码模块被称为“类加载器”。

类加载器虽然只作用与实现类的加载动作，但它在Java程序中起的作用却远远不止于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身来确立其在Java虚拟机的唯一性。

### 双亲委派模型

站在虚拟机的角度讲，存在两种不同的类加载器：

* 启动类加载器（Bootstrap ClassLoader），C++实现，是虚拟机的一部分
* 所有其他的类加载器，Java实现，独立虚拟机外部，全部继承java.lang.ClassLoader

从Java开发人员的角度，类加载器可以更细致分，绝大部分Java程序会用到一下三种：

* 启动类加载器（Bootstrap ClassLoader），这个类加载器负责将存放在&lt;JAVA_HOME>\lib目录中的，或被-Xbootclasspath参数指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用
* 扩展类加载器（Extension ClassLoader），这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有类库，开发者可以直接使用扩展类加载器
* 应用程序类加载器（Application ClassLoader），这个类加载器由sun.misc.Launcher$AppClassloader来实现，由于这个类加载器是ClassLoader中getSystemClassLoader()方法的返回值，也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用应用程序类加载器，如果程序中没有自定义类加载器，这个就是默认的类加载器

类加载器之间的关系如下图：

![](/img/virtual/classLoader.png)

上图所展示的类加载器之间的这种层次关系，就成为类加载器的双亲委派模型。双亲委派模型除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是以组合关系来复用父类加载器的代码。

#### 双亲委派模型的工作过程

如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传到底层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

#### 破坏双亲委派模型

到现在为止，双亲委派模型主要出现过三次大规模的破坏。

1. 由于双亲委派模型在JDK1.2之后才被引用的，而类加载器和抽象类java.lang.ClassLoader则在JDK1.0就存在，面试已经存在的用户自定义类加载器的实现代码，不得不做出妥协。为了向前兼容，JDK1.2之后的java.lang.ClassLoader添加了一个新的protected方法findClass(),在此之前，用户去继承java.lang.ClassLoader的唯一目的就是重写loadClass()方法，在此之后，是重写findClass()方法。
2. 由于这个模型自身的缺陷所导致的，双亲委派很好的解决各个类加载器的基础类的同一问题（越基础的类有越上层的加载器进行加载）。基础类之所以被成为“基础”，是因为它们总是作为被用户代码调用的API，但如果基础类又要回调用户代码，怎么办？线程上下文类加载器，这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个：如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI,JDBC,JCE,JAXB和JBI等。
3. 由于用户对于程序动态性的追求所导致的，这里所说的“动态性”指的是非常“热”的名词：代码热替换，模块热部署等。

参考：

1. 《深入理解Java虚拟机》








